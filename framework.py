import sys
import os
import zipfile

malware = sys.argv[1]
reportname = 'none'
filetype = malware.split('.')[1]
isPDF = False
isMSoffice = False
isZip = False
extensionEqual = False

if 'pdf' in filetype:
	isPDF = True
if 'xls' in filetype or 'doc' in filetype:
	isMSoffice = True

header = True
info = False
abstract = ''
report = ''

def addToAbstract( str ):
	global abstract
	abstract += str

def addToReport( str ):
	global report
	report += str

def runFileTypeChange( input ):
	global filetype
	global isPDF
	global isMSoffice
	global isZip

	filetype = input

	isPDF = False
	isMSoffice = False
	isZip = False

	print('Changed to: ' + filetype)

	if 'pdf' in filetype:
		isPDF = True
	if 'doc' in filetype or 'xls' in filetype:
		isMSoffice = True
"""
FIRST PART IS USING TRID TO DECIDE WHICH FILETYPES IS CONTAINED IN THE DOCUMENT
TrID - FIle Identifier v2.20

ONLY THE ANALYSIS IS PRINTED TO THE END USER. NOTHING IS ADDED TO ABSTRACT YET.
"""

def trid():
	addToReport('Following file types is detected in the file:\n')
	global info
	global filetype
	global extensionEqual
	
	trid = os.popen('trid ' + malware).read()
	for line in trid.splitlines():
		if '%' in line:
			info = True
			addToReport('--' + line + '\n')
		if ('.' + filetype.upper()) in line:
			extensionEqual = True
	if not info:
		addToReport('Error: No info from TrID')
	if info:
		info = False
	if extensionEqual:
		addToReport('\nStatic filetype comparison APPROVED:\nThe filetypes detecting in the file is equivalent to the file-extension.\n\n')
	else:
		addToReport('\nStatic filetype comparison NOT APPROVED:\nWarning: The filetype detected is NOT equivalent to the file-extension.\n\n')



"""
SECOND PART USES EXIFTOOL TO EXTRACT DOCUMENT INFO
EXIFTOOL v9.46

RELEVANT FIELDS ARE PRINTED TO END USER. NOTHING IS ADDED TO ABSTRACT.
"""
def exiftool():
	global extensionEqual
	global reportname
	addToReport('\nFollowing meta-data is found in file.\nPlease compare the data, to the expexted content of the file:')

	exiftool = os.popen('exiftool ' + malware).read()
	for line in exiftool.splitlines():
		if line.split(':')[1].strip():
			info = True
			if 'Directory' not in line and 'ExifTool' not in line and 'File Type' not in line:
				addToReport(line + '\n')
			if (not extensionEqual) and 'File Type' in line and 'Extension' not in line:
				runFileTypeChange(line.split(':')[1].strip().lower())
			if 'Name' in line:
				reportname = line.split(':')[1].strip().lower()
	if not info:
		addToReport('Error: No info from ExifTool\n')
	if info:
		info = False

"""
THIRD PART USES MACRORAPTOR TO ANALYSE DOCUMENT FOR MACROS
MacroRaptor v0.50

RELEVANT FIELDS ARE PRINTED TO END USER. EXIT CODE IS ADDED TO ABSTRACT.
"""

def mraptor():
	addToReport('\n\nChecking for macros:\n')
	global header
	
	mraptor = os.popen('mraptor ' + malware).read()
	for line in mraptor.splitlines():
		if 'Result' in line:
			header=False
		if 'Exit code' in line:
			addToAbstract('Classified ' + line.split('-')[1].strip() + ' by MacroRaptor\n')
			header=True
		if not header:
			addToReport(line + '\n')
	addToReport('\n')

"""
FOURTH PART USES A SELECTION OF OLE-TOOLS TO EXTRACT DOCUMENT INFO
FIRST WE CHECK WHETHER THE DOCUMENT IS OLE-FORMATTED, USING OLEID. IF DOCUMENT IS OLE-FORMATTED WE USE OLEMETA AND OLETIMES TO EXTRACT INFO FROM OLE-FORMATTING

"""
def oletools():
	oleformat = False
	
	oleid = os.popen('oleid ' + malware).read()
	for line in oleid.splitlines():
		if 'OLE format' in line:
			if 'True' in line:
				oleformat = True
				ole = 'Document is OLE formatted and includes info of\n'

	if oleformat:
		for line in oleid.splitlines():
			if 'True' in line and 'OLE format' not in line:
				if 'VBA' in line:
					addToAbstract('Contains macros\n')
				ole += ('--' + line.split('|')[1].strip() + '\n')
		addToReport(ole+ '\n')
	
		olemeta = os.popen('olemeta ' + malware).read()
		for line in olemeta.splitlines():
			if 'Property' in line:
				header=False
			if 'Properties' in line:
				header=True
			if not header:
				addToReport(line + '\n')
		header = True
		addToReport('\n\n')
			
		oletimes = os.popen('oletimes ' + malware).read()
		for line in oletimes.splitlines():
			if 'Modification' in line:
				header=False
			if not header:
				if '|' in line and ('None' not in line.split('|')[2] or 'None' not in line.split('|')[3]):
					addToReport(line + '\n')
		header = True
	addToReport('\n\n')

"""
OLEVBA
MAKES AN EXHAUSTIVE MACRO ANALYSIS
"""

def olevba():
	correct_output = False
	olevba = os.popen('olevba -a ' + malware).read()
	for line in olevba.splitlines():
		if correct_output and '|'  in line:
			out = line.split('|')
			if 'Suspicious' in out[1] or 'AutoExec' in out[1]:
				addToReport('--' + out[3] + '\n')
		if 'Type' in line and 'Description' in line:
			correct_output = True
			addToReport('Macro execution:\n')
	addToReport('\nCompare the behaviour of the macro with your expectations.\n\n')

"""
VIRUSTOTAL.COM API. WE CHECK IF THE FILE HAS BEEN UPLOADED BEFORE.
PRINTS THE RESULT IN THE ABSTRACT.

NOTE THAT API ONLY ALLOWS 4 CALLS PR MINUTE
"""

def virusTotal():
	scanned = False
	nextline = False

	virustotal = os.popen('vt -fs ' + malware).read()
	for line in virustotal.splitlines():
		if nextline:
			addToReport(line.strip() + '\n')
			nextline = not nextline
		if 'Scanned on' in line:
			scanned = True
			nextline = True
			addToReport('Received and scanned on VirusTotal.com: ')
		if 'Detections' in line:
			nextline = True
			addToReport(line.strip() + '\n')
	if not scanned:
		addToReport('No data at VirusTotal.com\n')
	addToReport('\n')

"""
NEXT PART USES BUILD-IN ANTI-VIRUS, CLAMSCAN
WE ONLY CHECK WHETHER THE FILE IS INFECTION. IF SO IT IS ADDED TO THE ABSTRACT
"""
def clamscan():
	clamscan = os.popen('clamscan ' + malware).read()
	for line in clamscan.splitlines():
		if 'Infected files' in line:
			if '1' in line.split(':')[1]:
				addToReport('Recognised as a malicious file by anti-virus engine.')
				addToAbstract('Classified INFECTED by ClamAV\n')
			else:
				addToReport('No infection found.')
				addToAbstract('Classified CLEAN by ClamAV\n')

"""
FIRST PART IS USING AnalyzePDF TO CHECK FOR SUSPECIOUS CONTENT IN THE PDF FILE

"""
def analyzepdf():
	addToReport('Analyzing PDF for suspecious objects..\n')
	analyzepdf = os.popen('python /opt/AnalyzePDF/AnalyzePDF.py ' + malware).read()
	for line in analyzepdf.splitlines():
		if '!' in line:
			addToReport(line.translate(None, '[!]').lstrip() + '\n')
			addToAbstract('Classified ' + line.translate(None, '[!]').lstrip() + '\n')

"""
SECOND PART IS USING PeePDF TO CHECK FOR SUSPECIOUS CONTENT IN THE PDF FILE

"""
def peepdf():
	global info
	peepdf = os.popen('/opt/peepdf/peepdf.py -flg ' + malware).read()
	for line in peepdf.splitlines():
		if 'CVE' in line:
			info = False
			exploit = line[line.find('(')+1:line.find(')')]
			addToReport('Contains known exploitation method: ' + exploit + '\nThe document will try to use a known vulnerability to infect the machine\n')
			addToAbstract('Contains known exploitation method: ' + exploit + '\n')
		if info:
			addToReport('-' + line.split(':')[0].translate(None, "/").lstrip() + '\n')	
		if 'JS code' in line:
			addToReport('Contains Javascript\n')
		if 'Suspicious' in line:
			addToReport('Contains suspecious elements:\n')
			info = True
	info = False

"""
SANDBOXING USING CUCKOO. REQUIRES PROPER CONFIGURATION OF CUCKOO. 

"""
def sandbox():
	os.popen('cuckoo submit --platform windows ' + malware).read()
	sandboxresult = open('/storage/analyses/analysis.log', 'r')
	for line in sandboxresult.splitlines():
		addToReport(line)

################################################################
# MAIN PART
# WORKS WELL
################################################################

trid()
exiftool()
if isMSoffice:
	mraptor()
	oletools()
	olevba()
if isPDF:
	analyzepdf()
	peepdf()
virusTotal()
clamscan()
sandbox()

abstract = ('File name is ' + reportname + '\nFiletype is ' + filetype.upper() + '\n\n') + abstract
userreport = open('analyses/' + reportname.split('.')[0] + '_' + filetype + '_malware_report.txt', 'w')
userreport.write(report)
userreport.close()

usermail = open('returns/usermail.txt', 'a')
usermail.write(abstract)
usermail.close()
